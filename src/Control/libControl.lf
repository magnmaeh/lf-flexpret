target C

preamble {=
    #include <platform.h>

#if defined(PLATFORM_FLEXPRET)
    #define sleep_custom(x) do { \
        uint64_t start = rdtime64(); \
        while ((rdtime64() - start) < (x * USEC(1))); \
    } while(0)
#elif __linux__
    #include <unistd.h>
    #define sleep_custom(x) do { \
        usleep((x - 150)); \
    } while(0)
#endif
=}

reactor Logger(n_iterations: int = 10) {
    input ts_sensor: instant_t
    input ts_process: instant_t
    input ts_actuator: instant_t

    state iteration: int = 0
    state ts: instant_t*

    reaction(startup) {=
        self->ts = malloc(3 * self->n_iterations * sizeof(instant_t));
    =}

    reaction(ts_sensor) {=
        self->ts[self->iteration++] = ts_sensor->value;
    =}

    reaction(ts_process) {=
        self->ts[self->iteration++] = ts_process->value;
    =}

    reaction(ts_actuator) {=
        self->ts[self->iteration++] = ts_actuator->value;
    =}

    reaction(shutdown) {=
        for (int i = 0; i < self->n_iterations; i++) {
#if defined(PLATFORM_FLEXPRET)
            printf("[%i]: sampled: %lli, processed: %lli, actuated: %lli\n",
                i,
                self->ts[3 * i + 0],
                self->ts[3 * i + 1],
                self->ts[3 * i + 2]
            );
#elif __linux__
            printf("[%i]: sampled: %li, processed: %li, actuated: %li\n",
                i,
                self->ts[3 * i + 0],
                self->ts[3 * i + 1],
                self->ts[3 * i + 2]
            );
#endif
        }
        free(self->ts);
    =}
}

reactor Sensor(n_iterations: int = 10) {
    output y: int
    output ts: instant_t

    state it: int = 0
    timer t(50 msec, 10 msec)

    state data: int[] = {=
        {
#include "normal.txt"
        };
    =}

    reaction(t) -> y, ts {=
        lf_set(y, self->data[self->it++]);
        lf_set(ts, lf_time_physical() - lf_time_logical());
    =}
}

reactor SensorLaptop(n_iterations: int = 10) {
    output y: int
    output ts: instant_t

    state it: int = 0
    timer t(50 msec, 10 msec)

    state data: int[] = {=
        {
#include "../../../src/normal.txt"
        };
    =}

    reaction(t) -> y, ts {=
        lf_set(y, self->data[self->it++]);
        lf_set(ts, lf_time_physical() - lf_time_logical());
    =}
}

reactor ProcessUnbounded {
    input x: int
    output y: int
    output ts: instant_t

    reaction(x) -> y, ts {=
        // "Process" for value time, this introduces jitter
        sleep_custom(x->value);


        lf_set(y, x->value);
        lf_set(ts, lf_time_physical() - lf_time_logical());
    =}
}

reactor ProcessBounded {
    input x: int
    output y: int
    output ts: instant_t

    preamble {=
        void isr(void) { }
    =}

    reaction(startup) {=
        register_isr(EXC_CAUSE_INTERRUPT_EXPIRE, isr);
        ENABLE_INTERRUPTS();
    =}

    reaction(x) -> y, ts {=
        INTERRUPT_ON_EXPIRE(lf_time_logical() + MSEC(1), cleanup);
        
        // "Process" for value time, this introduces jitter
        sleep_custom(x->value);

        interrupt_on_expire_cancel();

    cleanup:
        lf_set(y, x->value);
        lf_set(ts, lf_time_physical() - lf_time_logical());
    =}
}

reactor Actuator(n_iterations: int = 10) {
    input x: int
    output ts: instant_t

    state it: int = 0

    reaction(x) -> ts {=
        lf_set(ts, lf_time_physical() - lf_time_logical());

        // Actuate with x
        if (++self->it == self->n_iterations) {
            printf("Stop after %i iterations\n", self->it);
            lf_request_stop();
        }
    =}
}
