target C {
    threading: true,
    logging: error,
    build: "../scripts/build_flexpret_unix.sh"
}

preamble {=
    #include <platform.h>
    #include "config.h"

    #define MAX_ITERATIONS (CONFIG_ITERATIONS)
    #define NSTAGES (1)
    #define TIMESTAMP_SIZE ((1 + NSTAGES) * MAX_ITERATIONS)
    
    #define IDX_BASE(i)         ((1 + NSTAGES) * i + (    0))
    #define IDX_DATA(i, j)      ((1 + NSTAGES) * i + (j + 1))
    
    static float compute_part_0(float f) {
        lf_sleep(MSEC(10));
        return f + 1;
    }
    

    static void print_timings(uint32_t iter, instant_t *timestamps)
    {
        char printout[256];
        int len = sprintf(printout, "Iteration %i: Base: %lli, ", iter, timestamps[(1 + NSTAGES) * iter]);
        for (int j = 0; j < NSTAGES; j++) {
            if (timestamps[(1 + NSTAGES) * iter + (j + 1)] != 0) {
                len += sprintf(printout + len - 1, "{%i}: %lli, ", j, timestamps[(1 + NSTAGES) * iter + (j + 1)]) - 1;
            } else {
                len += sprintf(printout + len - 1, "{%i}: NA, ", j) - 1;
            }
        }
        
        printf("%s\n", printout);
    }
=}

main reactor(start: time = 100 msec) {
    state processed: float
    state niterations: int = 0
    state timestamps: instant_t[]

    timer t(0, 10 msec)

    reaction(startup) -> stage0.timestamps {=
        fp_assert(NSTAGES == NUMBER_OF_WORKERS, "Number of stages not equal to number of workers!\n");
        self->timestamps = malloc(TIMESTAMP_SIZE * sizeof(instant_t));

        lf_set(stage0.timestamps, self->timestamps);
    =}

    reaction(t) -> stage0.x, stage0.niterations {=
        self->timestamps[IDX_BASE(self->niterations)] = lf_time_physical_elapsed();
        lf_set(stage0.x, 10.0);

        lf_set(stage0.niterations, self->niterations);
    =}

    stage0 = new PipelineStage(stage = 0);


    reaction(stage0.y) {=
        self->processed = stage0.y->value;
        if (++self->niterations == MAX_ITERATIONS) {
            printf("request stop\n");
            lf_request_stop();
        }
    =}

    reaction(shutdown) {=
        // Remove the parts of the pipeline that were empty in the beginning
        for (int j = 0; j < NSTAGES; j++) {
            for (int k = 1; k < (NSTAGES - j); k++) {
                self->timestamps[(1 + NSTAGES) * j + (j + k + 1)] = 0;
            }
        }

        for (int i = 0; i < self->niterations; i++) {
            print_timings(i, self->timestamps);
        }

        free(self->timestamps);
    =}
}

reactor PipelineStage(stage: int = 0) {
    input x: float
    input niterations: int
    input timestamps: instant_t[]
    output y: float
    reaction(x, niterations, timestamps) -> y {=
        instant_t time_elapsed = lf_time_physical_elapsed();
        timestamps->value[IDX_DATA(niterations->value, self->stage)] = time_elapsed;

        float result = 0;
        switch (self->stage) {
            case 0: result = compute_part_0(x->value); break;

            default: break;
        }
        lf_set(y, result);
    =}
}
